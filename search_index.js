var documenterSearchIndex = {"docs":
[{"location":"storage/#Storage","page":"Storage","title":"Storage","text":"","category":"section"},{"location":"storage/","page":"Storage","title":"Storage","text":"CurrentModule = ClosedGroupFunctions\nDocTestSetup = quote\n    using ClosedGroupFunctions\nend","category":"page"},{"location":"storage/","page":"Storage","title":"Storage","text":"This package provides a simple interface for (de)serialize for convenience. If you want to use a specific file extension, just use the filename_suffix parameter, e.g. for .dat use filename_suffix = \".dat\".","category":"page"},{"location":"storage/#Storing-a-group","page":"Storage","title":"Storing a group","text":"","category":"section"},{"location":"storage/","page":"Storage","title":"Storage","text":"store_group(identifier, group; filename_prefix = \"closed_group_\", filename_suffix = \"\")","category":"page"},{"location":"storage/#ClosedGroupFunctions.store_group-Tuple{Any, Any}","page":"Storage","title":"ClosedGroupFunctions.store_group","text":"store_group(identifier, group; filename_prefix = \"closed_group_\", filename_suffix = \"\")\n\nStores a given group as a serialized array in a file. The identifier could be something like \"n\" where n is a characteristic number.\n\n\n\n\n\n","category":"method"},{"location":"storage/","page":"Storage","title":"Storage","text":"info: Info\nThe stored object doesn't need to be a group. It can be used to store specific elements of the group, the labelled group or other arbitrary objects.","category":"page"},{"location":"storage/#Loading-a-group","page":"Storage","title":"Loading a group","text":"","category":"section"},{"location":"storage/","page":"Storage","title":"Storage","text":"load_group(identifier; filename_prefix = \"closed_group_\", filename_suffix = \"\")","category":"page"},{"location":"storage/#ClosedGroupFunctions.load_group-Tuple{Any}","page":"Storage","title":"ClosedGroupFunctions.load_group","text":"load_group(identifier; filename_prefix = \"closed_group_\", filename_suffix = \"\") -> group\n\nLoads a serialized group from a given file and returns the group.\n\n\n\n\n\n","category":"method"},{"location":"gens/#Generating-and-Labelling","page":"Generating and Labelling","title":"Generating and Labelling","text":"","category":"section"},{"location":"gens/","page":"Generating and Labelling","title":"Generating and Labelling","text":"CurrentModule = ClosedGroupFunctions\nDocTestSetup = quote\n    using ClosedGroupFunctions\nend","category":"page"},{"location":"gens/","page":"Generating and Labelling","title":"Generating and Labelling","text":"Assuming you already have a list of generators of a finite group, the group under closure can be calculated with the following functions.","category":"page"},{"location":"gens/#Basic-generator","page":"Generating and Labelling","title":"Basic generator","text":"","category":"section"},{"location":"gens/","page":"Generating and Labelling","title":"Generating and Labelling","text":"The basic, very efficient group generator takes an array of generators of type T and yields a tuple with a Set of all group elements of type T and the number of multiplications that were needed to calculate the whole group.","category":"page"},{"location":"gens/","page":"Generating and Labelling","title":"Generating and Labelling","text":"group_generator_basic(generators::Array{T}; prnt = false, commutes=false) where T","category":"page"},{"location":"gens/#ClosedGroupFunctions.group_generator_basic-Union{Tuple{Array{T, N} where N}, Tuple{T}} where T","page":"Generating and Labelling","title":"ClosedGroupFunctions.group_generator_basic","text":"group_generator_basic(generators::Array{T}; prnt=false) -> Set(group), num_all_mult\n\nCalculate all other elements of this closed group by multiplying all generators and storing new elements and then multiplying the generators again with the new elements. Very efficient with O(Omega cdot N) multiplications.  It is the most efficient algorithm for a given set of generators. Only the use of smaller sets of generators can reduce the number of multiplications further.\n\nThe prnt variable can be used to specify if the programm should output the progressbar. This can slow things down.\n\n\n\n\n\n","category":"method"},{"location":"gens/#Labelling","page":"Generating and Labelling","title":"Labelling","text":"","category":"section"},{"location":"gens/#Labelling-of-the-generators","page":"Generating and Labelling","title":"Labelling of the generators","text":"","category":"section"},{"location":"gens/","page":"Generating and Labelling","title":"Generating and Labelling","text":"A given array of generators of type T can be converted to a labelled Bijection using","category":"page"},{"location":"gens/","page":"Generating and Labelling","title":"Generating and Labelling","text":"label_generators(generators::Array{T}; alphabet = default_alphabet()) where T","category":"page"},{"location":"gens/#ClosedGroupFunctions.label_generators-Union{Tuple{Array{T, N} where N}, Tuple{T}} where T","page":"Generating and Labelling","title":"ClosedGroupFunctions.label_generators","text":"label_generators(generators::Array{T}; alphabet::Vector{Char}) -> labelled_generators::Bijection{String, T}\n\nLabels the given generators using the given alphabet, a vector of characters and returns the labelled generators. The alphabet can be bigger than the number of generators, only the first Ω = length(generators) characters are used.\n\n\n\n\n\n","category":"method"},{"location":"gens/","page":"Generating and Labelling","title":"Generating and Labelling","text":"info: Info\nThere the default_alphabet() returns an alphabet with 103 possible characters that can be used for labelling (For bigger generator-lists, please use your own character list). The default alphabet consists of 'a':'z', 'A':'Z', '𝒜':'𝒵' and 'α':'ω'.","category":"page"},{"location":"gens/#Labelling-of-the-group","page":"Generating and Labelling","title":"Labelling of the group","text":"","category":"section"},{"location":"gens/","page":"Generating and Labelling","title":"Generating and Labelling","text":"There are two functions, that can be used to label the whole group.","category":"page"},{"location":"gens/","page":"Generating and Labelling","title":"Generating and Labelling","text":"The 'simple' generator is fast and stores the first occuring label of every element. It stops if every element is calculated - for this to work, the final number of elements (from the result of the basic generator) has to be provided.","category":"page"},{"location":"gens/","page":"Generating and Labelling","title":"Generating and Labelling","text":"labelled_group_generator_simple(labelled_generators::Bijection{String, T}, num_max_elements::Int64; prnt = false, commutes=false) where T","category":"page"},{"location":"gens/#ClosedGroupFunctions.labelled_group_generator_simple-Union{Tuple{T}, Tuple{Bijections.Bijection{String, T}, Int64}} where T","page":"Generating and Labelling","title":"ClosedGroupFunctions.labelled_group_generator_simple","text":"labelled_group_generator_simple(labelled_generators::Bijection{String, T}, num_max_elements::Int64; prnt = false) -> labelled_group::Bijection{String, T}\n\nFast Method: Generates all group elements and labels them with the first occuring label. It stops after generating num_max_elements elements. The resulting label may not be the shortest possible label. The generators can be given to the function either as a labelled Bijection{String, T} or as an unlabelled Array{T} that will automatically labelled.\n\n\n\n\n\n","category":"method"},{"location":"gens/","page":"Generating and Labelling","title":"Generating and Labelling","text":"The 'shortest' method works analogous to the basic generator - it calculates every element and every possible multiplication and stores only the shortest occuring label of every element. This method can be quite slow because the difference in the storage: while the basic generator uses a Set{T} that automatically only keeps one copy of every element, the labelled generators use a Bijection{String, T} that is a bit slower. Aside from that, every time an element is calculated the function needs to check, if the new label is shorter than the stored one and switch the entries if so.","category":"page"},{"location":"gens/","page":"Generating and Labelling","title":"Generating and Labelling","text":"labelled_group_generator_shortest(labelled_generators::Bijection{String, T}; prnt = false, commutes=false) where T","category":"page"},{"location":"gens/#ClosedGroupFunctions.labelled_group_generator_shortest-Union{Tuple{Bijections.Bijection{String, T}}, Tuple{T}} where T","page":"Generating and Labelling","title":"ClosedGroupFunctions.labelled_group_generator_shortest","text":"labelled_group_generator_shortest(labelled_generators::Bijection{String, T}; prnt = false)::Tuple{Bijection{String, T}, Int64} -> labelled_group::Bijection{String, T}, num_all_mult::Int64\n\nFor the general method and description of prnt see group_generator_basic(). Slow Method: This method generates all other elements of the closed group and labels them using the shortest possible label. As Bijections are slower than Sets and replacing the longer-labelled Pair with the shorter-labelled Pair is time consuming, this method can be really slow compared to group_generator_basic().\n\n\n\n\n\n","category":"method"},{"location":"conj/#Conjugacy-Classes","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"","category":"section"},{"location":"conj/","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"CurrentModule = ClosedGroupFunctions\nDocTestSetup = quote\n    using ClosedGroupFunctions\nend","category":"page"},{"location":"conj/","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"For some groups (particularly matrix groups) the concept of conjugacy classes is important. ","category":"page"},{"location":"conj/","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"The conjugacy class of an element g in mathscrG is defined as","category":"page"},{"location":"conj/","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"Cl(g) = h cdot g cdot h^-1  h in mathscrG","category":"page"},{"location":"conj/","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"where h^-1 is the inverse element inv(h) to h with hcdot h^-1 = e where e is the identity element of the group.","category":"page"},{"location":"conj/","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"This package provides some functions to handle conjugacy classes.","category":"page"},{"location":"conj/#Calculating-all-conjugacy-classes","page":"Conjugacy Classes","title":"Calculating all conjugacy classes","text":"","category":"section"},{"location":"conj/","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"The conjugacy classes can be calculated either using Julia's internal inv() function, or by providing a function as the inverse parameter.","category":"page"},{"location":"conj/","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"calculate_conjugacy_classes(group::Bijection{String, T}; inverse=inv, prnt=true) where T","category":"page"},{"location":"conj/#ClosedGroupFunctions.calculate_conjugacy_classes-Union{Tuple{Bijections.Bijection{String, T}}, Tuple{T}} where T","page":"Conjugacy Classes","title":"ClosedGroupFunctions.calculate_conjugacy_classes","text":"calculate_conjugacy_classes(group::Bijection{String, T}; inverse=inv, prnt=true) -> conjugacy_classes::Vector{Set{String}}\n\nCalculate all conjugacy classes {Cl(g) = {h * g * h^{-1} | h ∈ 𝒢}} for a given finite, closed group, given the inverse function for elements of type T in the group group. The inverse function defaults to the Julia inv function. prnt enables/disables output of the class-sizes and remaining elements while computing the classes.\n\n\n\n\n\n","category":"method"},{"location":"conj/","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"info: Info\nEvery element occurs only in one conjugacy classes. A disjoint union (dotcup) of all conjugacy classes of mathscrG yields again mathscrG.","category":"page"},{"location":"conj/#Investigating-classes","page":"Conjugacy Classes","title":"Investigating classes","text":"","category":"section"},{"location":"conj/","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"Conjugacy classes or any other sub-list of labelled elements of a labelled group can be investigated further by applying functions, here called an invariant because of the connection with conjugacy classes and functions, that are constant for a given class (but every function that expects only a group element of type T can be used).","category":"page"},{"location":"conj/#Is-function-invariant?","page":"Conjugacy Classes","title":"Is function invariant?","text":"","category":"section"},{"location":"conj/","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"is_invariant(class::Set{String}, group::Bijection{String, T}, invariant; prnt=true) where T","category":"page"},{"location":"conj/#ClosedGroupFunctions.is_invariant-Union{Tuple{T}, Tuple{Set{String}, Bijections.Bijection{String, T}, Any}} where T","page":"Conjugacy Classes","title":"ClosedGroupFunctions.is_invariant","text":"is_invariant(class::Set{String}, group::Bijection{String, T}, invariant) -> (is_invariant::Bool, values::Vector)\n\nVerifies that the given function invariant is an invariant for a given (conjugacy) class. The class is given by labels that match the corresponding elements in the Bijection group.\n\n\n\n\n\n","category":"method"},{"location":"conj/#Applying-a-function-to-the-class(es)","page":"Conjugacy Classes","title":"Applying a function to the class(es)","text":"","category":"section"},{"location":"conj/#To-every-element-of-one-class","page":"Conjugacy Classes","title":"To every element of one class","text":"","category":"section"},{"location":"conj/","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"apply_invariant_to_all_in_class(class::Set{String}, group::Bijection{String, T}, invariant; prnt=true) where T","category":"page"},{"location":"conj/#ClosedGroupFunctions.apply_invariant_to_all_in_class-Union{Tuple{T}, Tuple{Set{String}, Bijections.Bijection{String, T}, Any}} where T","page":"Conjugacy Classes","title":"ClosedGroupFunctions.apply_invariant_to_all_in_class","text":"apply_invariant_to_all_in_class(class::Set{String}, group::Bijection{String, T}, invariant; prnt=true) -> values::Vector\n\nCalculates the values of invariant for every element of a given class. The class is given by labels that match the corresponding elements in the Bijection group.\n\n\n\n\n\n","category":"method"},{"location":"conj/#To-the-first-element-of-one-class","page":"Conjugacy Classes","title":"To the first element of one class","text":"","category":"section"},{"location":"conj/","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"apply_invariant_to_first_in_class(class::Set{String}, group::Bijection{String, T}, invariant) where T","category":"page"},{"location":"conj/#ClosedGroupFunctions.apply_invariant_to_first_in_class-Union{Tuple{T}, Tuple{Set{String}, Bijections.Bijection{String, T}, Any}} where T","page":"Conjugacy Classes","title":"ClosedGroupFunctions.apply_invariant_to_first_in_class","text":"apply_invariant_to_first_in_class(class::Set{String}, group::Bijection{String, T}, invariant) -> value\n\nCalculates the value of invariant for the first element of a given class. The class is given by labels that match the corresponding elements in the Bijection group.\n\n\n\n\n\n","category":"method"},{"location":"conj/#To-the-first-element-of-every-given-class","page":"Conjugacy Classes","title":"To the first element of every given class","text":"","category":"section"},{"location":"conj/","page":"Conjugacy Classes","title":"Conjugacy Classes","text":"apply_invariant_to_first_in_all_classes(conjugacy_classes::Vector{Set{String}}, group::Bijection{String, T}, invariant; prnt=true) where T","category":"page"},{"location":"conj/#ClosedGroupFunctions.apply_invariant_to_first_in_all_classes-Union{Tuple{T}, Tuple{Vector{Set{String}}, Bijections.Bijection{String, T}, Any}} where T","page":"Conjugacy Classes","title":"ClosedGroupFunctions.apply_invariant_to_first_in_all_classes","text":"apply_invariant_to_first_in_all_classes(conjugacy_classes::Vector{Set{String}}, group::Bijection{String, T}, invariant; prnt=true) -> values::Vector\n\nCalculates the values of invariant for the first element of all given classes. The conjugacy_classes are given by Sets of labels that match the corresponding elements in the Bijection group.\n\n\n\n\n\n","category":"method"},{"location":"other/#Other-functions-and-Helpers","page":"Other functions and Helpers","title":"Other functions and Helpers","text":"","category":"section"},{"location":"other/","page":"Other functions and Helpers","title":"Other functions and Helpers","text":"CurrentModule = ClosedGroupFunctions\nDocTestSetup = quote\n    using ClosedGroupFunctions\nend","category":"page"},{"location":"other/","page":"Other functions and Helpers","title":"Other functions and Helpers","text":"Modules = [ClosedGroupFunctions]\nPages = [\"helpers.jl\", \"labelled_group_generator.jl\"]","category":"page"},{"location":"other/#ClosedGroupFunctions.group_element_calculate-Union{Tuple{T}, Tuple{String, Bijections.Bijection{String, T}, T}} where T","page":"Other functions and Helpers","title":"ClosedGroupFunctions.group_element_calculate","text":"group_element_calculate(expr::String, group::Bijection{String, T}, identity_element::T) -> key::String\n\nCalculate the expression expr using the labels defined in group. The group identity_element is necessary.\n\nUsage:\n\nLet G be a labelled group.\nLet I be the identity element from G.\nDefine a shorthand:   Gcalc(expr::String) = group_element_calculate(expr, G, I)\nUse Gcalc()`.\n\n\n\n\n\n","category":"method"},{"location":"other/#ClosedGroupFunctions.default_alphabet-Tuple{}","page":"Other functions and Helpers","title":"ClosedGroupFunctions.default_alphabet","text":"default_alphabet()\n\nDefines a default list of characters that are used to label the generators. Maximum is currently 103 symbols. The default alphabet consists of 'a':'z', 'A':'Z', '𝒜':'𝒵' and 'α':'ω'.\n\n\n\n\n\n","category":"method"},{"location":"#ClosedGroupFunctions.jl-Documentation","page":"ClosedGroupFunctions.jl Documentation","title":"ClosedGroupFunctions.jl Documentation","text":"","category":"section"},{"location":"","page":"ClosedGroupFunctions.jl Documentation","title":"ClosedGroupFunctions.jl Documentation","text":"CurrentModule = ClosedGroupFunctions\nDocTestSetup = quote\n    using ClosedGroupFunctions\nend","category":"page"},{"location":"#Installation","page":"ClosedGroupFunctions.jl Documentation","title":"Installation","text":"","category":"section"},{"location":"","page":"ClosedGroupFunctions.jl Documentation","title":"ClosedGroupFunctions.jl Documentation","text":"] add git@github.com:Fhoeddinghaus/ClosedGroupFunctions.jl.git","category":"page"},{"location":"","page":"ClosedGroupFunctions.jl Documentation","title":"ClosedGroupFunctions.jl Documentation","text":"or ","category":"page"},{"location":"","page":"ClosedGroupFunctions.jl Documentation","title":"ClosedGroupFunctions.jl Documentation","text":"] add https://github.com/Fhoeddinghaus/ClosedGroupFunctions.jl.git","category":"page"},{"location":"#Contents","page":"ClosedGroupFunctions.jl Documentation","title":"Contents","text":"","category":"section"},{"location":"","page":"ClosedGroupFunctions.jl Documentation","title":"ClosedGroupFunctions.jl Documentation","text":"Pages = [\"gens.md\", \"conj.md\", \"storage.md\", \"other.md\"]\nDepth = 3","category":"page"},{"location":"#Index","page":"ClosedGroupFunctions.jl Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"ClosedGroupFunctions.jl Documentation","title":"ClosedGroupFunctions.jl Documentation","text":"","category":"page"}]
}
